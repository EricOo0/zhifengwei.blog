# 计算机网络

<details>
<summary>ICMP</summary>

ICMP 网络控制消息协议，用于在IP协议中发送控制消息，运行在IP层，用于测试网络状况等  
ping和tracroute发送的式ICMP报文  
ICMP报文负责差错控制--负责错误报告，不负责错误纠正（IP报文只负责消息传输，不管差错控制）  
常见错误：终点不可达，超时，源点抑制  
</details>

<details>
<summary>DNS</summary>

DNS是域名系统（Domain Name System），是将域名和IP地址的之间进行转换的一项服务gethostbyname  
域名转换时会先区浏览器缓存查询域名对应的IP，如果没有，会去本地HOSTS里查询，如果没有才会到DNS服务 器上去寻找。  
DNS运行在应用层，域名解析是基于UDP的（块，简单）  
</details>

<details>
<summary>ICMP</summary>

ARP地址解析协议，提供IP地址和MAC地址的转换服务；属于网络层  
ARP地址请求是广播，向所有用户请求目的IP的mac地址；arp回复是单播。  
linux下用 arp -a 查看arp缓存；一个地址在arp缓存中有老化时间，过期会被删除。  
arp攻击：arp是一种不安全的协议--arp洪泛 arp欺骗  
</details>

## TCP/IP和UDP部分

* TCP和UDP区别：  
    
>Tcp面向连接，需要三次握手四次挥手，是可靠传输;而udp不面向连接是不可靠传输（尽最大努力传输）  
TCP是字节流而UDP是报文  
TCP有拥塞避免（作用于网络）-慢开始，快恢复，快重传，流量控制（作用于接收放，接收窗口），UDP无  
TCP适用于文件传输等对可靠性要求高的（邮件，文件传输），UDP适用于实时应用（语言，视频）  
TCP首部20字节，UDP首部8字节  
TCP慢，资源消耗多，udp快，资源消耗少  

* 拥塞避免算法：  
>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。  
**慢开始**算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小  
**拥塞避免**当拥塞窗口大于拥塞门限，采用拥塞避免算法，即拥塞窗口线性增加+1  
当发生超时情况--没有收到确认就认为是网络拥塞，慢开始门限设为当前拥塞窗口一半，拥塞窗口设为1  
**快重传**：发送方收到连续三个同一个确认报文，就直接重传，不等超时  
**快恢复**：发送方收到连续三个同一个确认报文，把慢开始门限设为一半，执行拥塞避免算法  
>>TCP报文结构:  
    头部包含：源目的端口号，序号与确认序号，校验和，报文长度，数据偏移（UDP可能在IP层分片）等  
    
* 分包和粘包：  

>当发送间隔很短，包长度很小时，socket内部会把几个报文打包成一个发送
当报文太大的时候，socket内部会拆分成几个报文发送
解决办法：加头部，标明数据长度，或加起止标志

* 四次挥手的状态分别是：
>1、客户端发送请求关闭报文fin ,客户端进入fin_wait1
2、服务器接收fin并回复fin_ack,服务器进入close_wait
3、客户端接收ack，客户端进入fin_wait2;
4、服务器发出关闭请求fin，服务器进入last_ack
5、客户端接收并回复确认，进入time_wait状态
四次挥手是因为全双工，为了双方断开

* 三次握手的状态：
>1、客户端发出syn请求，进入Syn_send状态
2、服务器接收syn，回复syn+ack，进入syn_recv状态
3、客户端接收到syn+ack，回复ack，客户端进入established状态
4、服务器接收到ack,进入established
为什么要三次握手，因为tcp是全双工的，需要测速双方的收发能力都是正常的。

* 可以两次握手吗?  
>不可以，如果只进行两次握手：
1、当服务器的确认丢失的时候，服务器以为成功建立了连接，但客户端却认为没有建立。此时服务器向客户端发送数据会被丢弃
2、客户端发出连接请求超时后到达服务器，服务器仍接收请求发出确认，但客户端此时不需要建立连接，浪费资源
* 为什么要有time_wait 阶段
>1、客户端发送第四次挥手中的报文后，再经过2MSL，可使本次TCP连接中的所有报文全部消失，不会出现在下一个TCP连接中。
2、考虑丢包问题，如果第四挥手发送的报文在传输过程中丢失了，那么服务端没收到确认ack报文就会重发第三次挥手的报文。如果客户端发送完第四次挥手的确认报文后直接关闭，而这次报文又恰好丢失，则会造成服务端无法正常关闭。
* 如果已经建立了连接，但是客户端突然出现故障了怎么办？
>如果TCP连接已经建立，在通信过程中，客户端突然故障，那么服务端不会一直等下去，过一段时间就关闭连接了。具体原理是TCP有一个保活机制，主要用在服务器端，用于检测已建立TCP链接的客户端的状态，防止因客户端崩溃或者客户端网络不可达，而服务器端一直保持该TCP链接，占用服务器端的大量资源(因为Linux系统中可以创建的总TCP链接数是有限制的)。
* 初始化双发的序列号；为什么要随机初始化
>防止被攻击
* UDP最大报文长度：
>1480（因为以太网帧长度为1500，ip首部20字节）
* 第三次握手失败怎么办？
>服务器超时没收到请求重传，5次失败后关闭连接；客户端如果此时发送数据会受到RST响应包
![image1 tcp](https://github.com/EricOo0/my_repo/blob/master/Image/tcp.jpg)



## HTTP 部分

* http和https区别？  
>端口：http-80  https-443  
安全性：https有加密机制更安全  
协议：http运行在tcp之上，https运行在ssl层上（安全套接字层）而ssl运行在tcp层上。  
* https过程:  
>HTTPS实际上就是HTTP穿上了SSL/TLS的外套; 增加一层SSL（安全套接字）  
密钥磋商过程：  
客户端发起一个http请求，连接端口443  
服务器把自己的数字证书，公钥等信息发给客户端（非对称密钥）  
客户端验证证书合法性，生成对称密钥，用公钥加密后发给服务器  
* HTTP请求过程：  
>域名解析（DNS）获得IP -> 对服务器发起TCP连接（3次握手）-> 连接成功后可以发送http请求（post，get）->服务器响应，发送页面->浏览器解析渲染  
* 状态码：  
>2xx：成功响应 3xx:重定向状态码 4xx：客户端错误 5xx:服务器错误  
* http格式：  
>请求行（request line-请求方法+url+协议版本）、请求头部（header）、空行和请求数据4个部分  
* HTTP长连接短链接：  
>Http 1.0：短链接 耗费太多资源，每次发送都有链接  
Http 1.1：长连接+心跳机制keeplive  --长链接的目的可以复用   
比如请求一个网页：如果是短链接-需要建立十几个tcp链接，传输css，js等一系列资源；长链接的话只需要复用一个tcp链接
长链接+连接池--防止高并发占用太多资源  
http2.0:特点：多路复用-允许单个连接多个请求
http3.0:基于UDP，主要是快-减少了握手的时间和TLS；解决弱网情况下队头阻塞等问题；
* http端口号  
>http端口是80 https是443  
* HTTP的无连接和无状态  
>HTTP协议是应用层协议，主要五大特点：支持客户-服务器模式，简单快速，灵活，无连接，无状态  
>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态，服务器无法判断用户身份。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。--（用cookie和session解决）  
>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。  
* session和cookie  
>**Cookie**  
    Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会像客户端浏览器发送一个Cookie，客户端会把Cookie存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。  
**Session**    
    Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。比如浏览器访问的是购物网站，将一本《图解HTTP》放到了购物车，当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取会话中的存储的信息，确认浏览器的身份是上次将《图解HTTP》放入到购物车那个用户。  
**Token**
    客户端在浏览器第一次访问服务端时，服务端生成的一串字符串作为Token发给客户端浏览器，下次浏览器在访问服务端时携带token即可无需验证用户名和密码，省下来大量的资源开销。  

## 其他

* 什么是nginx：  
>Nginx是一款轻量级的Web服务器、也可以用来做反向代理服务，具有简单的负载均衡；  
支持高并发（epoll，多进程，多路复用和事件通知）-异步非阻塞，响应更快-可以缓存静态文件（作为缓存服务器）  
启动Nginx后，其实就是在80端口启动了Socket服务进行监听  
分为master进程和worker进程（多进程单线程-）  
* Ospf,rip,stp的理解：  
* DHCP协议：  
>动态获取IP；四个过程：发现过程（寻找dhcp服务器地址）提供阶段（服务区提供IP）选择阶段（客户端选择第一个提供的IP）确认阶段（服务器确认）  
